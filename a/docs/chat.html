<!DOCTYPE html>
<html>
<head>
  <title>Private Chat</title>
</head>
<body>

<h3 id="me"></h3>
<button onclick="logout()">üö™ Logout</button>
<hr>

<select id="receiver"></select>
<br><br>

<input id="msg" placeholder="Type message">
<button onclick="send()">Send</button>

<hr>

<button onclick="startCall()">üìû Call</button>
<button onclick="endCall()">‚ùå End Call</button>

<p id="callStatus" style="font-weight:bold;color:green;"></p>

<hr>

<div id="chat"></div>

<audio id="remoteAudio" autoplay></audio>
<audio id="ringtone" loop preload="auto">
  <source src="ringtone.mp3" type="audio/mpeg">
</audio>

<p id="typing" style="font-style:italic;color:gray;"></p>

<script src="/socket.io/socket.io.js"></script>
<script>
/* =========================
   BASIC SETUP
========================= */
const API = "https://bappa-s-web.onrender.com";
const socket = io(API);

const userId   = localStorage.getItem("userId");
const userName = localStorage.getItem("userName");

if (!userId || !userName) {
  alert("Please login first");
  location.href = "/";
}

document.getElementById("me").innerText = "You: " + userName;

const receiverSelect = document.getElementById("receiver");
const chat        = document.getElementById("chat");
const msgInput    = document.getElementById("msg");
const typingEl    = document.getElementById("typing");
const callStatus  = document.getElementById("callStatus");
const remoteAudio = document.getElementById("remoteAudio");
const ringtone    = document.getElementById("ringtone");

/* =========================
   CALL STATE + TIMER
========================= */
let CALL_STATE = "IDLE"; // IDLE | CALLING | RINGING | CONNECTED
let callTimer = null;
let callSeconds = 0;

function startTimer(){
  stopTimer();
  callSeconds = 0;
  callTimer = setInterval(()=>{
    callSeconds++;
    callStatus.innerText = `Call connected (${callSeconds}s)`;
  },1000);
}

function stopTimer(){
  if(callTimer) clearInterval(callTimer);
  callTimer = null;
  callSeconds = 0;
}

/* =========================
   SOCKET ONLINE
========================= */
socket.emit("addUser", userId);
socket.emit("getOnlineUsers");

let ONLINE = [];

socket.on("onlineUsers", list => {
  ONLINE = list;
  loadUsers();
});

/* =========================
   LOAD USERS
========================= */
async function loadUsers(){
  const res = await fetch(API + "/users?me=" + userId);
  const users = await res.json();
  receiverSelect.innerHTML = "";

  users.forEach(u=>{
    const opt = document.createElement("option");
    opt.value = u._id;
    opt.textContent = `${ONLINE.includes(u._id) ? "üü¢" : "‚ö™"} ${u.name}`;
    receiverSelect.appendChild(opt);
  });

  if(receiverSelect.value) loadHistory(receiverSelect.value);
}

/* =========================
   CHAT HISTORY
========================= */
async function loadHistory(receiverId){
  typingEl.innerText = "";
  const res = await fetch(API + "/chat/" + userId + "/" + receiverId);
  const msgs = await res.json();

  chat.innerHTML = "";
  msgs.forEach(m=>{
    chat.innerHTML +=
      m.senderId === userId
      ? `<p><b>You:</b> ${m.text}</p>`
      : `<p><b>Them:</b> ${m.text}</p>`;
  });
}

receiverSelect.onchange = ()=> loadHistory(receiverSelect.value);

/* =========================
   TYPING
========================= */
let typingTimeout;
msgInput.addEventListener("input", ()=>{
  const rid = receiverSelect.value;
  if(!rid) return;

  socket.emit("typing",{ senderName:userName, receiverId:rid });
  clearTimeout(typingTimeout);
  typingTimeout = setTimeout(()=>{
    socket.emit("stopTyping",{ receiverId:rid });
  },1000);
});

socket.on("typing", d=>{
  typingEl.innerText = `${d.senderName} is typing...`;
});
socket.on("stopTyping", ()=> typingEl.innerText="");

/* =========================
   SEND MESSAGE
========================= */
function send(){
  const rid = receiverSelect.value;
  const text = msgInput.value;
  if(!text) return;

  socket.emit("sendMessage",{
    senderId:userId,
    senderName:userName,
    receiverId:rid,
    text
  });

  socket.emit("stopTyping",{ receiverId:rid });
  typingEl.innerText="";
  chat.innerHTML += `<p><b>You:</b> ${text}</p>`;
  msgInput.value="";
}

socket.on("getMessage", d=>{
  typingEl.innerText="";
  chat.innerHTML += `<p><b>${d.senderName}:</b> ${d.text}</p>`;
});

/* =========================
   WEBRTC
========================= */
let pc, localStream;
const RTC_CONFIG = { iceServers:[{urls:"stun:stun.l.google.com:19302"}] };

async function initWebRTC(){
  pc = new RTCPeerConnection(RTC_CONFIG);

  pc.onicecandidate = e=>{
    if(e.candidate){
      socket.emit("webrtc-ice",{ to:receiverSelect.value, candidate:e.candidate });
    }
  };

  pc.ontrack = e=>{
    remoteAudio.srcObject = e.streams[0];
  };

  localStream = await navigator.mediaDevices.getUserMedia({audio:true});
  localStream.getTracks().forEach(t=>pc.addTrack(t,localStream));
}

/* =========================
   CALL LOGIC
========================= */
async function startCall(){
  if(CALL_STATE!=="IDLE") return;

  CALL_STATE="CALLING";
  callStatus.innerText="Calling...";

  socket.emit("callUser",{
    callerId:userId,
    callerName:userName,
    receiverId:receiverSelect.value
  });
}

socket.on("incomingCall", async d=>{
  CALL_STATE="RINGING";
  ringtone.play();

  const ok = confirm(`üìû ${d.callerName} is calling`);
  ringtone.pause(); ringtone.currentTime=0;

  if(!ok){
    socket.emit("rejectCall",{ callerId:d.callerId });
    CALL_STATE="IDLE";
    return;
  }

  socket.emit("acceptCall",{ callerId:d.callerId });
  CALL_STATE="CONNECTED";
  callStatus.innerText="Call connected";
  startTimer();
});

socket.on("callAccepted", async ()=>{
  CALL_STATE="CONNECTED";
  await initWebRTC();
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  socket.emit("webrtc-offer",{ to:receiverSelect.value, offer });
  startTimer();
});

socket.on("callRejected", ()=>{
  CALL_STATE="IDLE";
  callStatus.innerText="Call rejected";
});

/* =========================
   WEBRTC SIGNALING
========================= */
socket.on("webrtc-offer", async offer=>{
  await initWebRTC();
  await pc.setRemoteDescription(offer);
  const answer = await pc.createAnswer();
  await pc.setLocalDescription(answer);
  socket.emit("webrtc-answer",{ to:receiverSelect.value, answer });
});

socket.on("webrtc-answer", a=> pc.setRemoteDescription(a));
socket.on("webrtc-ice", c=> c && pc.addIceCandidate(c));

/* =========================
   END CALL
========================= */
function endCall(){
  CALL_STATE="IDLE";
  stopTimer();
  callStatus.innerText="Call ended";

  if(pc) pc.close();
  if(localStream) localStream.getTracks().forEach(t=>t.stop());
  pc=null; localStream=null;

  socket.emit("endCall",{ otherUserId:receiverSelect.value });
}

socket.on("callEnded", ()=>{
  CALL_STATE="IDLE";
  stopTimer();
  callStatus.innerText="Call ended";
});

/* =========================
   LOGOUT
========================= */
function logout(){
  ringtone.pause(); ringtone.currentTime=0;
  socket.disconnect();
  localStorage.clear();
  location.href="/";
}

loadUsers();
</script>
</body>
</html>
