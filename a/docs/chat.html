<!DOCTYPE html>
<html>
<head>
  <title>Private Chat</title>
</head>
<body>

<h3 id="me"></h3>
<button onclick="logout()">ğŸšª Logout</button>
<hr>

<select id="receiver"></select>

<br><br>

<input id="msg" placeholder="Type message">
<button onclick="send()">Send</button>

<hr>

<button onclick="startCall()">ğŸ“ Call</button>
<button onclick="endCall()">âŒ End Call</button>

<p id="callStatus" style="font-weight:bold;color:green;"></p>

<hr>

<div id="chat"></div>
<audio id="remoteAudio" autoplay></audio>
<p id="typing" style="font-style:italic;color:gray;"></p>

<script src="/socket.io/socket.io.js"></script>
<script>
  const API = "https://bappa-s-web.onrender.com"; // local à¦¹à¦²à§‡ http://localhost:3000
  const socket = io(API);

  const userId = localStorage.getItem("userId");
  const userName = localStorage.getItem("userName");

  if (!userId || !userName) {
    alert("Please login first");
    location.href = "/";
  }

  document.getElementById("me").innerText = "You: " + userName;

  const receiverSelect = document.getElementById("receiver");
  const chat = document.getElementById("chat");
  const msgInput = document.getElementById("msg");
  const typingEl = document.getElementById("typing");
  const callStatus = document.getElementById("callStatus");
  const remoteAudio = document.getElementById("remoteAudio");

  let typingTimeout;
  let ONLINE = [];

  // =========================
  // ğŸ”Œ SOCKET ONLINE
  // =========================
  socket.emit("addUser", userId);
  socket.emit("getOnlineUsers");

  socket.on("onlineUsers", (list) => {
    ONLINE = list;
    loadUsers();
  });

  // =========================
  // ğŸ‘¥ LOAD USERS
  // =========================
  async function loadUsers() {
    const res = await fetch(API + "/users?me=" + userId);
    const users = await res.json();

    receiverSelect.innerHTML = "";

    users.forEach(u => {
      const opt = document.createElement("option");
      opt.value = u._id;
      const status = ONLINE.includes(u._id) ? "ğŸŸ¢" : "âšª";
      opt.textContent = `${status} ${u.name}`;
      receiverSelect.appendChild(opt);
    });

    if (receiverSelect.value) {
      loadHistory(receiverSelect.value);
    }
  }

  // =========================
  // ğŸ’¬ CHAT HISTORY
  // =========================
  async function loadHistory(receiverId) {
    typingEl.innerText = "";
    const res = await fetch(API + "/chat/" + userId + "/" + receiverId);
    const msgs = await res.json();

    chat.innerHTML = "";
    msgs.forEach(m => {
      if (m.senderId === userId) {
        chat.innerHTML += `<p><b>You:</b> ${m.text}</p>`;
      } else {
        chat.innerHTML += `<p><b>Them:</b> ${m.text}</p>`;
      }
    });
  }

  receiverSelect.onchange = () => {
    loadHistory(receiverSelect.value);
  };

  // =========================
  // âœï¸ TYPING
  // =========================
  msgInput.addEventListener("input", () => {
    const receiverId = receiverSelect.value;
    if (!receiverId) return;

    socket.emit("typing", { senderName: userName, receiverId });

    clearTimeout(typingTimeout);
    typingTimeout = setTimeout(() => {
      socket.emit("stopTyping", { receiverId });
    }, 1000);
  });

  socket.on("typing", (data) => {
    typingEl.innerText = `${data.senderName} is typing...`;
  });

  socket.on("stopTyping", () => {
    typingEl.innerText = "";
  });

  // =========================
  // ğŸ“© SEND MESSAGE
  // =========================
  function send() {
    const receiverId = receiverSelect.value;
    const text = msgInput.value;
    if (!text) return;

    socket.emit("sendMessage", {
      senderId: userId,
      senderName: userName,
      receiverId,
      text
    });

    socket.emit("stopTyping", { receiverId });
    typingEl.innerText = "";

    chat.innerHTML += `<p><b>You:</b> ${text}</p>`;
    msgInput.value = "";
  }

  socket.on("getMessage", (data) => {
    typingEl.innerText = "";
    chat.innerHTML += `<p><b>${data.senderName}:</b> ${data.text}</p>`;
  });

  // =========================
  // ğŸ”Š WEBRTC AUDIO
  // =========================
  let pc;
  let localStream;

  const RTC_CONFIG = {
    iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
  };

  async function initWebRTC() {
    pc = new RTCPeerConnection(RTC_CONFIG);

    pc.onicecandidate = (e) => {
      if (e.candidate) {
        socket.emit("webrtc-ice", {
          to: receiverSelect.value,
          candidate: e.candidate
        });
      }
    };

    pc.ontrack = (e) => {
      remoteAudio.srcObject = e.streams[0];
    };

    localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
  }

  // =========================
  // ğŸ“ CALL
  // =========================
  async function startCall() {
    const receiverId = receiverSelect.value;
    if (!receiverId) return;

    callStatus.innerText = "Calling...";

    await initWebRTC();

    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);

    socket.emit("callUser", {
      callerId: userId,
      callerName: userName,
      receiverId
    });

    socket.emit("webrtc-offer", {
      to: receiverId,
      offer
    });
  }

  socket.on("incomingCall", async (data) => {
    const ok = confirm(`ğŸ“ ${data.callerName} is calling. Accept?`);
    if (!ok) {
      socket.emit("rejectCall", { callerId: data.callerId });
      return;
    }

    callStatus.innerText = "Call connected";
  });

  socket.on("callAccepted", () => {
    callStatus.innerText = "Call connected";
  });

  socket.on("callRejected", () => {
    callStatus.innerText = "Call rejected";
  });

  // =========================
  // ğŸ” WEBRTC SIGNALING
  // =========================
  socket.on("webrtc-offer", async (offer) => {
    await initWebRTC();
    await pc.setRemoteDescription(offer);

    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);

    socket.emit("webrtc-answer", {
      to: receiverSelect.value,
      answer
    });
  });

  socket.on("webrtc-answer", async (answer) => {
    await pc.setRemoteDescription(answer);
  });

  socket.on("webrtc-ice", async (candidate) => {
    if (candidate) await pc.addIceCandidate(candidate);
  });

  // =========================
  // âŒ END CALL
  // =========================
  function endCall() {
    if (pc) pc.close();
    if (localStream) localStream.getTracks().forEach(t => t.stop());
    pc = null;
    localStream = null;

    socket.emit("endCall", { otherUserId: receiverSelect.value });
    callStatus.innerText = "Call ended";
  }

  socket.on("callEnded", () => {
    callStatus.innerText = "Call ended";
  });

  // =========================
  // ğŸšª LOGOUT
  // =========================
  function logout() {
    socket.disconnect();
    localStorage.clear();
    location.href = "/";
  }

  // init
  loadUsers();
</script>

</body>
</html>
